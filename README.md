Краткая документация к тестовому заданию

Используемые архитектурные решения

1. Архитектура с использованием Zenject

Zenject был выбран в качестве Dependency Injection (DI) контейнера для управления зависимостями. Это позволило:

Упростить создание и конфигурирование объектов.

Легко заменять зависимости, что упрощает тестирование и рефакторинг.

Минимизировать связность компонентов, улучшая читаемость и модульность.

2. Модульная структура

Проект разделён на модули, такие как:

Core: базовые компоненты, интерфейсы и утилиты.

Player: логика игрока, управление его состояниями и взаимодействие с окружением.

Enemy: логика врагов, включая их движение, здоровье и взаимодействие с игроком.

StateSystem: система управления состояниями для игрока.

Effects: визуальные эффекты, такие как параллакс и прокрутка.

UI: управление пользовательским интерфейсом.

Items: предметы и их взаимодействие с игроком.

Installers: настройка зависимостей с помощью Zenject.

Используемые паттерны проектирования

1. Паттерн "Фабрика"

Использован для создания игровых объектов, таких как враги и пули. Это позволило:

Инкапсулировать логику создания объектов.

Упростить управление пулом объектов.

Избежать дублирования кода.

Пример: BulletFactory создаёт экземпляры пуль с использованием пула объектов.

2. Паттерн "Наблюдатель"

Использован для реализации взаимодействия между компонентами игры (например, управление событиями интерфейса или взаимодействие объектов).

Система событий уведомляет подписчиков об изменениях, таких как обновление счетчика пуль или завершение игры.

3. Паттерн "Состояния"

Реализован для управления состояниями игрока. Это позволило:

Упростить добавление новых состояний.

Избежать громоздких условных конструкций.

Чётко разделить логику разных состояний.

Пример: PlayerStateMachine управляет переходами между состояниями, такими как атака, движение и покой.

Заключение

Проект построен с использованием современных подходов к архитектуре и разработке. Использование Zenject, а также популярных паттернов, позволило создать структуру, удобную для дальнейшего расширения и поддержки. Такой подход позволяет легко адаптировать игру под новые требования и добавлять новые механики.

